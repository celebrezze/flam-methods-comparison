---
title: 'PCA (trial 2) and NMDS'
author: "Joe Celebrezze"
date: "3/8/2022"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading in necessary packages
```{r, include = FALSE}
library(tidyverse)
library(here)
here = here::here
library(ggbiplot) #for nicer PCA plots
library(factoextra) #to gather PCA values
ggbiplot = ggbiplot::ggbiplot
library(psych) #for pairs.panels()
library(sjPlot) #for nice tables of eigenvalues
library(RColorBrewer) #to change color palette
library(vegan)#for NMDS analysis
library(ggpubr) #for ggarrange (to put graphs side by side)
library(kableExtra) #for nice tables of eigenvalues (I like better than sjPlot -- more customizable)
select = dplyr::select
#Add in packages as necessary so no redundant packages

col3 = hcl.colors(10, "YlOrRd", rev = TRUE) #color scale to use for consistency 
```

# Loading in dataset
```{r, include = FALSE}
main_df <- read_csv(here("processed-data/bothmethods_bothlocations_long.csv"))
wide_df <- read_csv(here("processed-data/bothmethods_bothlocations_wide.csv"))
```

# Visualization Function
- Using this for quick exploratory PCA visualization, but will use more lines of code and use ggplot2 to do final versions of the visualizations
```{r}
PCAvis <- function(pca_obj, group_by, colors = c("#FED976", "#E31A1C"), pc1_name = "PC1", pc2_name = "PC2", group_name = "Model"){
  ggbiplot(pca_obj,
         groups = group_by,
         ellipse = TRUE, circle = FALSE, varname.size = 4, alpha = 0.5) +
  theme_bw() + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        aspect.ratio = 1/1,
        axis.title = element_text(face = 'bold'),
        legend.title = element_text(face = 'bold')) +
  labs(x = pc1_name, y = pc2_name, color = group_name) +
  scale_color_manual(values = colors)
}
```

# ------------------------------------
# Exploratory PCA
The following scripts are the first go-through of PCAs to try and understand how the flammability metrics related to each other and how the two methods compared in their breakdown of the flammability metrics

Select columns of interest from main_df to run PCA on:
```{r}
pca_df <- main_df %>% 
  select(spp, model, mpa, fh, ttfg, gti, tti, fd, gd, pfg, dw_flam_sample, lfm_outliers_out, start_temp, location, temp_max, ignition_temp, sample_wt)

df_noNA <- na.omit(pca_df)
```

Look at distribution using pairs_panels():
```{r}
pca_df %>% 
  select(-spp,-model,-location) %>% 
  #Excluding columns that we wouldn't expect to have a normal distribution
  pairs.panels()
```

## PCA 1
Most of the continuous, numberical variables

Running a PCA without any significant changes to the dataset (only centering and scaling); including all relevant continuous, numerical variables (total of 16)

### Getting Eigenvalues
```{r}
#First, must exclude columns that are not numerical
str(pca_df) #spp, model, location should be excluded

pca_first_try <- pca_df %>% 
  select(-spp, -model, -location) %>%  #Excluding spp, model, location
  na.omit() %>%  #Getting rid of NAs
  prcomp(center = TRUE, scale = TRUE) #Running PCA

print(pca_first_try)
summary(pca_first_try) #First two principal components only describe 40.9% of variance
```

### Visualization and Table of Eigenvalues
```{r}
plot(pca_first_try, type = "lines") #Showing relative amounts of variance explained by first ten principal components; first FIVE principal components each explain a lot of variance

PCAvis(pca_first_try, group_by = df_noNA$model)

tab_pca(pca_first_try)
```

## PCA 2

For this PCA, will focus on the primary flammability metrics:
  Max temp, ignition temp, flame ht, time to first glow, glow to ignition, time to igniton, flame duration, glow duration, post-flame glow
  
This means that the following variables will be excluded:
  Moisture metrics -- mpa, lfm, fresh_wt, dry_wt
  Sample wt, start temp
  Flam. metrics -- proportion ignited (does not weight heavily on first two principal components, so wanted to see how things looked without it)
  
### Getting Eigenvalues
```{r}
flam_metrics_df <- df_noNA %>% 
  select(temp_max, fh, ttfg, gti, tti, fd, gd, pfg, spp, model)

pca_flam <- flam_metrics_df %>% 
  select(-spp, -model) %>% 
  na.omit() %>%  #Getting rid of NAs
  prcomp(center = TRUE, scale = TRUE) #Running PCA

print(pca_flam)
summary(pca_flam) #First two principal components describe 52% of variance
```

### Visualization and Table of Eigenvalues
```{r}
plot(pca_flam, type = "lines")

PCAvis(pca_flam, df_noNA$model)

tab_pca(pca_flam)
```

## PCA 3

Side-by-side Comparison of PCA for Flam. Metrics for EPI and HP

Note: this was done in trial 1 but with normalized flam. metrics

### Data Wrangling and Getting Eigenvalues
```{r}
flam_metrics_df_epi <- flam_metrics_df %>% 
  filter(model == "EPI")

pca_flam_epi <- flam_metrics_df_epi %>% 
  select(-spp, -model) %>% 
  prcomp(center = TRUE, scale = TRUE)

flam_metrics_df_hp <- flam_metrics_df %>% 
  filter(model == "HP")

pca_flam_hp <- flam_metrics_df_hp %>% 
  select(-spp, -model) %>% 
  prcomp(center = TRUE, scale = TRUE)
```

### Tables of Eigenvalues
```{r}
tab_pca(pca_flam_epi, fctr.load.tlrn = 0.01)
tab_pca(pca_flam_hp, fctr.load.tlrn = 0.01)
```

### Visualization
```{r}
epi.plot1 <- PCAvis(pca_flam_epi, flam_metrics_df_epi$spp, colors = c("#FFFF71", "#FEB24C", "#FC4E2A", "#B10026"), group_name = "Species") +
  labs(title = "Epiradiator")

hp.plot1 <- PCAvis(pca_flam_hp, flam_metrics_df_hp$spp, colors = c("#FFFF71", "#FEB24C", "#FC4E2A", "#B10026"), group_name = "Species") +
  labs(title = "Hot Plate")

ggarrange(epi.plot1, hp.plot1, ncol = 2)
```

## PCA 4

Separating by Species
```{r}
wide_df <- wide_df %>% 
  filter(ignition_hp == 1)

wide_df_flam.metrics <- wide_df %>% 
  select(tti_hp, tti_epi, fd_hp, fd_epi, fh_hp, fh_epi, gd_hp, gd_epi, temp_max_hp, temp_max_epi, gti_hp, gti_epi, pfg_hp, pfg_epi, ttfg_hp, ttfg_epi, spp_epi) %>% 
  na.omit()
```

### ADFA
```{r}
pca2_spp <- wide_df_flam.metrics %>% 
  filter(spp_epi == "ADFA") %>% 
  select(-spp_epi) %>% 
  prcomp(center = TRUE, scale = TRUE)

ggbiplot(pca2_spp,
         ellipse = TRUE, circle = FALSE, varname.size = 4, alpha = 0.5) +
  theme_bw() + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(face = 'bold'),
        legend.title = element_text(face = 'bold'),
        title = element_text(face = 'italic')) +
  labs(x = "PC1", y = "PC2", title = 'A. fasciculatum')
```

### ARPA
```{r}
pca2_spp <- wide_df_flam.metrics %>% 
  filter(spp_epi == "ARPA") %>% 
  select(-spp_epi) %>% 
  prcomp(center = TRUE, scale = TRUE)

ggbiplot(pca2_spp,
         ellipse = TRUE, circle = FALSE, varname.size = 4, alpha = 0.5) +
  theme_bw() + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.title = element_text(face = 'bold'),
        legend.title = element_text(face = 'bold'),
        title = element_text(face = 'italic')) +
  labs(x = "PC1", y = "PC2", title = 'A. patula')
```

# ---------------------------------
# MAIN PLOTS
## Flam. Metrics w/ Both Models
Plot setup:
```{r warning=FALSE}
figure_pca_quant <- (flam_metrics_df[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
         "temp_max")]) %>%  
 transmute("                Flame Duration" = fd,
          "Flame Height" = fh,
          "                  Post-flame Glow" = pfg,
          "Time to Ignition" = tti,
          "Max. Temp\n" = temp_max,
          "Glow Duration" = gd,
          "Glow to Ignition" = gti,
          "Time to First Glow" = ttfg
          )

figure_pca_cat <- (flam_metrics_df[c("model", "spp")]) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus",
    spp == "CECO" ~ "C. cordulatus",
    spp == "ARPA" ~ "A. patula"
  )) %>% 
  mutate(Model = case_when(
    model == "EPI" ~ "Epiradiator",
    model == "HP" ~ "Hot Plate"
  ))

#Setting up plotting data: 

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj.both <- figure_pca_quant %>% 
  prcomp(center = TRUE, scale = TRUE) #Running PCA

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj.both$x) - 1)
    d <- pcobj.both$sdev
    u <- sweep(pcobj.both$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj.both$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues <- cbind(df.u, figure_pca_cat)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("Flame Height", "Max. Temp\n","                Flame Duration"))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("Time to Ignition", "Glow to Ignition"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "                  Post-flame Glow", "Time to First Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)

#labels: 
u.axis.labs <- paste("PC", choices, sep = "")
u.axis.labs <- paste(u.axis.labs, sprintf("(%0.1f%% explained var.)", 
                                            100 * pcobj.both$sdev[choices]^2/sum(pcobj.both$sdev^2)))
```

Plot:
```{r}
ggplot(PCAvalues, aes(x = PC1, y = PC2)) +
  ylim(-4, 3) +
  geom_point(size = 2, alpha = .45, aes(color = Species,
                                           shape = Model)) +
  stat_ellipse(aes(x = PC1, y = PC2, fill = Model), colour = '#829191', alpha = 0.6, cex = 0.8) +
  labs(shape = "Method") +
  guides(color = guide_legend(order = 1, override.aes = list(size = 2.75)), shape = guide_legend(order = 2, override.aes = list(size = 2.75))) +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                              xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
      size = .9, alpha = 0.9) +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  annotate("text", 
           x = (PCA_combustability$PC1 * 1.4), 
          y = (PCA_combustability$PC2 * 1),
          label = PCA_combustability$Variables, size = 4.6,
          fontface = 'bold') +
  annotate("text",
           x = (PCA_ignitability$PC1 * 1.4), 
           y = (PCA_ignitability$PC2 * 1.125), 
           label = PCA_ignitability$Variables, size = 4.6,
           fontface = 'bold') +
  annotate("text",
           x = (PCA_consumability$PC1 * 1.3),
           y = (PCA_consumability$PC2 * 1.125), 
           label = PCA_consumability$Variables, size = 4.6,
           fontface = 'bold') + 
  annotate("text", x = -1.2, y = 1.4, label = "Epiradiator", colour = '#829191', fontface = 'bold', size = 6.5) +
  annotate("text", x = 1.5, y = -2.7, label = "Hot Plate", colour = '#829191', fontface = 'bold', size = 6.5) +
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.key = element_rect(fill = "white"),
          legend.position = 'right',
          legend.title = element_text(face = 'bold', size = 20),
          legend.text = element_text(face = 'italic', size = 18),
          axis.title = element_text(face = 'bold', size = 20),
          aspect.ratio = 1/1) +
  xlab(u.axis.labs[1]) + 
  ylab(u.axis.labs[2]) +
  scale_color_manual(values = c("#FC5130","#F7B801","#0B032D","#5F758E")) +
  coord_equal()

ggsave(here('figures/FigS3.PCAflammetrics.jpg'), height = 8, width = 12)
```

## Side-by-side PCAs
### EPI
Plot setup:
```{r warning=FALSE}
figure_pca_quant <- (flam_metrics_df_epi[, c("fh", "tti", "fd", "gd", "gti", "pfg", "ttfg", "temp_max")]) %>%  
 transmute("Flame Duration" = fd,
          "         Flame Height" = fh,
          "\nPost-flame Glow" = pfg,
          "\nTime to Ignition" = tti,
          "Max. Temp" = temp_max,
          "Glow Duration" = gd,
          "Glow to Ignition\n" = gti,
          "\nTime to First Glow" = ttfg
          )

figure_pca_cat.e <- (flam_metrics_df_epi[c("spp")]) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus",
    spp == "CECO" ~ "C. cordulatus",
    spp == "ARPA" ~ "A. patula"
  ))

#Setting up plotting data: 

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj.epi <- figure_pca_quant %>% 
  prcomp(center = TRUE, scale = TRUE) #Running PCA

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj.epi$x) - 1)
    d <- pcobj.epi$sdev
    u <- sweep(pcobj.epi$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj.epi$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues.epi <- cbind(df.u, figure_pca_cat.e)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("         Flame Height","Flame Duration"))
         
PCA_maxtemp <- df.v %>% 
  filter(Variables %in% c("Max. Temp"))

PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("\nTime to Ignition", "Glow to Ignition\n"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "\nPost-flame Glow"))

PCA_ttfg <- df.v %>% 
  filter(Variables %in% c( "\nTime to First Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)

#labels: 
u.axis.labs <- paste("PC", choices, sep = "")
u.axis.labs <- paste(u.axis.labs, sprintf("(%0.1f%% explained var.)", 
                                            100 * pcobj.epi$sdev[choices]^2/sum(pcobj.epi$sdev^2)))
```

Plot:
```{r}
epiPCA <- ggplot(PCAvalues.epi, aes(x = PC1, y = PC2)) +
  ylim(-3.25, 2.65) +
  geom_point(size = 1.85, alpha = .5) +
  #stat_ellipse(aes(x = PC1, y = PC2, color = Species), alpha = 0.65, cex = 0.8) +
  #guides(color = guide_legend(override.aes = list(size = 3))) +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                              xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
      size = .93, alpha = 0.9) +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9) +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9) +
  geom_segment(data = PCA_ttfg, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9, color = '#FC5130') +
  geom_segment(data = PCA_maxtemp, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9, color = '#FC5130') +
  annotate("text", 
           x = (PCA_combustability$PC1 * 1.85), 
          y = (PCA_combustability$PC2 * 1.12),
          label = PCA_combustability$Variables, size = 6,
          fontface = 'bold') +
  annotate("text",
           x = (PCA_ignitability$PC1 * 1.5), 
           y = (PCA_ignitability$PC2 * 1.125), 
           label = PCA_ignitability$Variables, size = 6,
           fontface = 'bold') +
  annotate("text",
           x = (PCA_consumability$PC1 * 1.5),
           y = (PCA_consumability$PC2 * 1.1), 
           label = PCA_consumability$Variables, size = 6,
           fontface = 'bold') + 
  annotate("text",
           x = (PCA_maxtemp$PC1 * 1.85),
           y = (PCA_maxtemp$PC2 * 1.12), 
           label = PCA_maxtemp$Variables, size = 6,
           fontface = 'bold', color = '#FC5130') +
  annotate("text",
           x = (PCA_ttfg$PC1 * 6),
           y = (PCA_ttfg$PC2 * 6), 
           label = PCA_ttfg$Variables, size = 6,
           fontface = 'bold', color = '#FC5130') +
    annotate("text", x = -2.7, y = 2.35, label = "a", size = 16, fontface = "bold") +
    annotate("text", x = 1.6, y = 2.35, label = "Epiradiator", size = 10) +
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.key = element_rect(fill = "white"),
          legend.position = 'none',
          legend.title = element_text(face = 'bold', size = 18),
          legend.text = element_text(face = 'italic', size = 16),
          axis.title = element_text(face = 'bold', size = 20),
          aspect.ratio = 1/1) +
  xlab(u.axis.labs[1]) + 
  ylab(u.axis.labs[2]) +
  coord_equal()

epiPCA
```


### HP
Plot setup:
```{r warning=FALSE}
figure_pca_quant <- (flam_metrics_df_hp[, c("fh", "tti", "fd", "gd", "gti", "pfg", "ttfg", "temp_max")]) %>%  
 transmute("Flame Duration" = fd,
          "                Flame Height" = fh,
          "\nPost-flame Glow" = pfg,
          "Time to Ignition" = tti,
          "Max. Temp      " = temp_max,
          "Glow Duration\n" = gd,
          "Glow to Ignition" = gti,
          "Time to First Glow" = ttfg
          )

figure_pca_cat <- (flam_metrics_df_hp[c("spp")]) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus",
    spp == "CECO" ~ "C. cordulatus",
    spp == "ARPA" ~ "A. patula"
  ))

#Setting up plotting data: 

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj.hp <- figure_pca_quant %>% 
  prcomp(center = TRUE, scale = TRUE) #Running PCA

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj.hp$x) - 1)
    d <- pcobj.hp$sdev
    u <- sweep(pcobj.hp$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj.hp$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues.hp <- cbind(df.u, figure_pca_cat)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("                Flame Height", "Flame Duration"))

PCA_maxtemp <- df.v %>% 
  filter(Variables %in% c("Max. Temp      "))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("Time to Ignition", "Glow to Ignition"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration\n", "\nPost-flame Glow"))

PCA_ttfg <- df.v %>% 
  filter(Variables %in% c("Time to First Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)

#labels: 
u.axis.labs <- paste("PC", choices, sep = "")
u.axis.labs <- paste(u.axis.labs, sprintf("(%0.1f%% explained var.)", 
                                            100 * pcobj.hp$sdev[choices]^2/sum(pcobj.hp$sdev^2)))

flam_metrics_df_hp$PC1 <- PCAvalues.hp$PC1
```

Plot:
```{r}
hpPCA <- ggplot(PCAvalues.hp, aes(x = PC1, y = PC2)) +
  ylim(-3.25, 2.65) +
  geom_point(size = 1.85, alpha = .5) +
  #stat_ellipse(aes(x = PC1, y = PC2, color = Species), alpha = 0.65, cex = 0.8) +
  #guides(color = guide_legend(override.aes = list(size = 3, shape = 16))) +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                              xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
      size = .93, alpha = 0.9) +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9) +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9) +
  geom_segment(data = PCA_maxtemp, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9, color = '#FC5130') +
  geom_segment(data = PCA_ttfg, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .93, alpha = 0.9, color = '#FC5130') +
  annotate("text", 
           x = (PCA_combustability$PC1 * 1.55), 
          y = (PCA_combustability$PC2 * 1.15),
          label = PCA_combustability$Variables, size = 6,
          fontface = 'bold') +
  annotate("text",
           x = (PCA_ignitability$PC1 * 1.55), 
           y = (PCA_ignitability$PC2 * 1.125), 
           label = PCA_ignitability$Variables, size = 6,
           fontface = 'bold') +
  annotate("text",
           x = (PCA_consumability$PC1 * 1.55),
           y = (PCA_consumability$PC2 * 1.15), 
           label = PCA_consumability$Variables, size = 6,
           fontface = 'bold') + 
  annotate("text", 
           x = (PCA_maxtemp$PC1 * 1.55), 
          y = (PCA_maxtemp$PC2 * 1.15),
          label = PCA_maxtemp$Variables, size = 6,
          fontface = 'bold', color = '#FC5130') +
  annotate("text",
           x = (PCA_ttfg$PC1 * 1.2),
           y = (PCA_ttfg$PC2 * 1.15),  
           label = PCA_ttfg$Variables, size = 6,
           fontface = 'bold', color = '#FC5130') +   
  annotate("text", x = -2.32, y = 2.35, label = "b", size = 16, fontface = 'bold') +
  annotate("text", x = 1.325, y = 2.35, label = "Hot Plate", size = 10) +
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.key = element_rect(fill = "white"),
          legend.position = 'none',
          legend.title = element_text(face = 'bold', size = 18),
          legend.text = element_text(face = 'italic', size = 16),
          axis.title = element_text(face = 'bold', size = 20),
          aspect.ratio = 1/1) +
  xlab(u.axis.labs[1]) + 
  ylab(u.axis.labs[2]) +
  coord_equal()

hpPCA
```

### Arranging
```{r}
PCA.epi.and.hp <- cowplot::plot_grid(epiPCA, hpPCA, ncol = 2, rel_widths = c(1,1))
PCA.epi.and.hp

ggsave(here('figures/Fig5.pca.sidebyside.jpg'), plot = PCA.epi.and.hp, height = 7.5, width = 16.5)
```

# MAIN TABLE

## Both Methods
```{r}
tab_pca(pcobj.both, 
        rotation = c("varimax"), 
        digits = 2,
        show.var = TRUE,
  string.pov = "Proportion of Variance",
  string.cpov = "Cumulative Proportion")
```

### Kable
First, making dataframe with eigenvalues for principal components, proportion of variance explained and cumulative proportion:
```{r}
eig1.both <- c(0.69, 0.88, 0.12, 0.72, -0.09, 0.14, -0.16, 0.87, 37.18, 37.18)
eig2.both <- c(0.20, 0.16, 0.95, 0.12, -0.03, 0.92, 0.20, -0.02, 23.37, 60.55)
eig3.both <- c(-0.27, -0.09, 0.00, 0.60, 0.10, 0.30, 0.90, 0.04, 13.40, 73.96)
flam.metrics <- c("Flame Duration", "Flame Height", "Post-flame Glow", "Time to Ignition", "Max. Temp.", "Glow Duration", "Glow to Ignition", "Time to First Glow", "Proportion of Variance (%)", "Cumulative Proportion (%)")
pca.table.df <- data.frame(flam.metrics, eig1.both, eig2.both, eig3.both)
```
there was probably a more elegant way to do that, but since there aren't too many numbers to enter in by hand, I thought it would be quicker to just go ahead and do so.

Now, using kableExtra package to visualize how each component is weighted by each flam. metric
```{r}
pca.table.df %>%
  mutate(flam.metrics = cell_spec(flam.metrics, 'html', bold = ifelse(flam.metrics == c("Proportion of Variance (%)", "Cumulative Proportion (%)"), T, F), color = 'black')) %>% 
  mutate(eig1.both = cell_spec(eig1.both, 'html', bold = ifelse(abs(eig1.both) > 0.5, T, F), color = 'black')) %>% 
  mutate(eig2.both = cell_spec(eig2.both, 'html', bold = ifelse(abs(eig2.both) > 0.5, T, F), color = 'black')) %>% 
  mutate(eig3.both = cell_spec(eig3.both, 'html', bold = ifelse(abs(eig3.both) > 0.5, T, F), color = 'black')) %>% 
  kable(format = 'html', escape = F, col.names = c(' ', 'Component 1', 'Component 2', 'Component 3')) %>% 
  kable_styling(bootstrap_options = c('hover', 'bordered', 'condensed'), fixed_thead = T, font_size = 30) %>% 
  row_spec(c(9:10), background = '#D3D3D3') %>% 
  save_kable(here('figures/pca_table_BOTH.html'))
```

## Side by Side
### EPI
```{r}
tab_pca(pcobj.epi, 
        rotation = c("varimax"), 
        digits = 2,
        show.var = TRUE,
  string.pov = "Proportion of Variance",
  string.cpov = "Cumulative Proportion")
```

### HP
```{r}
tab_pca(pcobj.hp, 
        rotation = c("varimax"), 
        digits = 10,
        show.var = TRUE,
  string.pov = "Proportion of Variance",
  string.cpov = "Cumulative Proportion")
```

### Kable
First, making dataframe with eigenvalues for principal components, proportion of variance explained and cumulative proportion:
```{r}
eig1.epi <- c(-0.44, 0.03, -0.90, -0.44, -0.08, -0.97, -0.51, 0.01, 33.19, 33.19)
eig2.epi <- c(-0.62, -0.68, -0.08, 0.59, -0.72, 0.06, 0.70, -0.06, 25.09, 58.28)
eig3.epi <- c(0.14, -0.26, -0.10, 0.52 , 0.15, 0.00, 0.11, -0.96, 16.04, 74.31)
###
eig1.hp <- c(0.02, 0.57, 0.09, -0.41, -0.64, -0.34, -0.83, -0.54, 30.72, 30.72)
eig2.hp <- c(-0.76, -0.15, 0.07, 0.81, -0.06, -0.02, 0.21, 0.62, 21.54, 52.26)
eig3.hp <- c(0.05, -0.31, -0.94, -0.08, -0.12, -0.89, -0.24, 0.19, 17.94, 70.19)
pca.table.df2 <- data.frame(flam.metrics, eig1.epi, eig2.epi, eig3.epi, eig1.hp, eig2.hp, eig3.hp)
```
there was probably a more elegant way to do that, but since there aren't too many numbers to enter in by hand, I thought it would be quicker to just go ahead and do so.

Now, using kableExtra package to visualize how each component is weighted by each flam. metric
```{r}
pca.table.df2 %>%
  mutate(flam.metrics = cell_spec(flam.metrics, 'html', bold = ifelse(flam.metrics == c("Proportion of Variance (%)", "Cumulative Proportion (%)"), T, F), color = 'black')) %>% 
  mutate(eig1.epi = cell_spec(eig1.epi, 'html', bold = ifelse(abs(eig1.epi) > 0.5, T, F), color = 'black')) %>%
  mutate(eig2.epi = cell_spec(eig2.epi, 'html', bold = ifelse(abs(eig2.epi) > 0.5, T, F), color = 'black')) %>% 
  mutate(eig3.epi = cell_spec(eig3.epi, 'html', bold = ifelse(abs(eig3.epi) > 0.5, T, F), color = 'black')) %>% 
  mutate(eig1.hp = cell_spec(eig1.hp, 'html', bold = ifelse(abs(eig1.hp) > 0.5, T, F), color = 'black')) %>% 
  mutate(eig2.hp = cell_spec(eig2.hp, 'html', bold = ifelse(abs(eig2.hp) > 0.5, T, F), color = 'black')) %>% 
  mutate(eig3.hp = cell_spec(eig3.hp, 'html', bold = ifelse(abs(eig3.hp) > 0.5, T, F), color = 'black')) %>% 
  kable(format = 'html', escape = F, col.names = c(' ', 'Component 1', 'Component 2', 'Component 3', 'Component 1', 'Component 2', 'Component 3')) %>% 
  kable_styling(bootstrap_options = c('hover', 'bordered', 'condensed'), fixed_thead = T, font_size = 30) %>% 
  row_spec(c(9:10), background = '#D3D3D3') %>%
  add_header_above(c(" ", "Epiradiator" = 3, "Hot Plate" = 3)) %>% 
  save_kable(here('figures/pca_table_SIDEbySIDE.html'))
```

# *-*-*-*-*-*-*-*-*-*-*-*-*-*
# Extra Analysis 1
## Flam. Metrics w/ Both Models
Scaled/centered prior to PCA
```{r}
epi_df <- flam_metrics_df %>% 
  filter(model == "EPI")
hp_df <- flam_metrics_df %>% 
  filter(model == "HP")


epi_df1 <- epi_df %>% 
  mutate(fh = fh - mean(fh), fd = fd - mean(fd), ttfg = ttfg - mean(ttfg), gti = gti -
          mean(gti), tti = tti - mean(tti), gd = gd - mean(gd), pfg = pfg - mean(pfg),
          temp_max = temp_max - mean(temp_max)) %>%  #centering
  mutate(fh = scale(fh), fd = scale(fd), ttfg = scale(ttfg), gti = scale(gti), tti =
           scale(tti), gd = scale(gd), pfg = scale(pfg), temp_max = scale(temp_max)) #scaled

hp_df1 <- hp_df %>% 
  mutate(fh = fh - mean(fh), fd = fd - mean(fd), ttfg = ttfg - mean(ttfg), gti = gti -
          mean(gti), tti = tti - mean(tti), gd = gd - mean(gd), pfg = pfg - mean(pfg),
          temp_max = temp_max - mean(temp_max)) %>%  #centering
  mutate(fh = scale(fh), fd = scale(fd), ttfg = scale(ttfg), gti = scale(gti), tti =
           scale(tti), gd = scale(gd), pfg = scale(pfg), temp_max = scale(temp_max)) #scaled
```

Stitching epi_df1 and hp_df1 together:
```{r}
flam_metrics_df1 <- bind_rows(epi_df1, hp_df1)
```

Plot setup:
```{r warning=FALSE}
figure_pca_quant <- (flam_metrics_df1[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
         "temp_max")]) %>%
  transmute("                Flame Duration" = fd,
          "\nFlame Height" = fh,
          "\n                  Post-flame Glow" = pfg,
          "Time to Ignition" = tti,
          "Max. Temp" = temp_max,
          "Glow Duration" = gd,
          "Glow to Ignition          " = gti,
          "Time to First Glow" = ttfg
          )

figure_pca_cat <- (flam_metrics_df[c("model", "spp")]) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus",
    spp == "CECO" ~ "C. cordulatus",
    spp == "ARPA" ~ "A. patula"
  )) %>% 
  mutate(Model = case_when(
    model == "EPI" ~ "Epiradiator",
    model == "HP" ~ "Hot Plate"
  ))

#Setting up plotting data: 

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj.both <- figure_pca_quant %>% 
  prcomp(center = TRUE, scale = TRUE) #Running PCA

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj.both$x) - 1)
    d <- pcobj.both$sdev
    u <- sweep(pcobj.both$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj.both$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues <- cbind(df.u, figure_pca_cat)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("\nFlame Height", "Max. Temp","                Flame Duration"))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("Time to Ignition", "Glow to Ignition          "))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "\n                  Post-flame Glow", "Time to First Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)

#labels: 
u.axis.labs <- paste("PC", choices, sep = "")
u.axis.labs <- paste(u.axis.labs, sprintf("(%0.1f%% explained var.)", 
                                            100 * pcobj.both$sdev[choices]^2/sum(pcobj.both$sdev^2)))
```

Plot:
```{r}
ggplot(PCAvalues, aes(x = PC1, y = PC2)) +
  ylim(-4, 3) +
  labs(shape = "Method") +
  geom_point(size = 2, alpha = .45, aes(color = Species,
                                           shape = Model)) +
  stat_ellipse(aes(x = PC1, y = PC2, fill = Model), colour = '#829191', alpha = 0.6, cex = 0.8) +
  guides(color = guide_legend(order = 1, override.aes = list(size = 2.75)), shape = guide_legend(order = 2, override.aes = list(size = 2.75))) +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                              xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
      size = .9, alpha = 0.9) +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  annotate("text", 
           x = (PCA_combustability$PC1 * 1.8), 
          y = (PCA_combustability$PC2 * 1.1),
          label = PCA_combustability$Variables, size = 4.6,
          fontface = 'bold') +
  annotate("text",
           x = (PCA_ignitability$PC1 * 1.4), 
           y = (PCA_ignitability$PC2 * 1.125), 
           label = PCA_ignitability$Variables, size = 4.6,
           fontface = 'bold') +
  annotate("text",
           x = (PCA_consumability$PC1 * 1.3),
           y = (PCA_consumability$PC2 * 1.125), 
           label = PCA_consumability$Variables, size = 4.6,
           fontface = 'bold') + 
  annotate("text", x = -1.2, y = 1.4, label = "Epiradiator", colour = '#829191', fontface = 'bold', size = 6.5) +
  annotate("text", x = 1.5, y = -2.7, label = "Hot Plate", colour = '#829191', fontface = 'bold', size = 6.5) +
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.key = element_rect(fill = "white"),
          legend.position = 'right',
          legend.title = element_text(face = 'bold', size = 20),
          legend.text = element_text(face = 'italic', size = 18),
          axis.title = element_text(face = 'bold', size = 20),
          aspect.ratio = 1/1) +
  xlab(u.axis.labs[1]) + 
  ylab(u.axis.labs[2]) +
  scale_color_manual(values = c("#FC5130","#F7B801","#0B032D","#5F758E")) +
  coord_equal()

ggsave(here('figures/FigS4.PCAflammetrics.scaled.centered.jpg'), height = 8, width = 12)
```

# -----------------------------
# Extra Analysis 2

## Coercing HP points onto PCA w/ EPI loadings and vice versa

### Step 1: Calculating PC1 using loadings, data

Here I am trying to calculate PC1 using only loadings and the flam. data

First I scaled and centered all of the flam. metrics created a matrix with all of those values and then I created a matrix with the loadings (which is a matrix of eigenvectors to my understanding) and multiplied the two matrices together.

I used the loadings from 'df.v' rather than the loadings reported in the PCA table as these were the conversion coefficients and were not adjusted in any way (whereas, on the table, they are adjusted so that maximum loading = |1|). I scaled manually rather than using the scale() function because the scale() function does not use the standard deviation to scale data. I then scaled the PC1/PC2 values I got from the matrix multiplication and the PC1 values were perfectly equivalent to those calculated from the PCA itself. 

If I follow this procedure, but use the loadings from the opposite PCA, then I can investigate whether the differences seen in the two PCAs are mostly due to the loadings of the PCA by the flam. metrics themselves or if the relationships between flammability metrics are inherently different for each method.

```{r}
flam_metrics_df_hp_scaled <- flam_metrics_df_hp %>%
  mutate(temp_max = (temp_max - mean(temp_max))/sd(temp_max), fh = (fh - mean(fh))/sd(fh), fd = (fd - mean(fd))/sd(fd), gti = (gti - mean(gti))/sd(gti), tti = (tti - mean(tti))/sd(tti), ttfg = (ttfg - mean(ttfg))/sd(ttfg), pfg = (pfg - mean(pfg))/sd(pfg), gd = (gd - mean(gd))/sd(gd)) %>%
  mutate(temp_max = temp_max - mean(temp_max), fh = fh - mean(fh), fd = fd - mean(fd), gti = gti - mean(gti), gd = gd - mean(gd), tti = tti - mean(tti), ttfg = ttfg - mean(ttfg), pfg = pfg - mean(pfg))

hp.flam.matrix <- flam_metrics_df_hp_scaled %>% 
  select(-spp, -model, -PC1) %>% 
  data.matrix()

loadings1 <- c(-0.8141884, 0.4040835, 0.5617811, -1.2490785, -0.8381545, 0.3472839, -1.2219867, -0.8181686)
loadings2 <- c(-0.04216584, -0.54172313, 0.85477658, 0.25941237, 1.08141147, -0.97275148, -0.62375045, -0.62382705)

eigenvectors <- data.frame(loadings1, loadings2)
eigenvectors.matrix <- data.matrix(eigenvectors)

pc1.estimates <- hp.flam.matrix%*%eigenvectors.matrix
pc1.est.df <- data.frame(pc1.estimates)
```

```{r}
flam_metrics_df_hp_scaled$PC1_test <- pc1.est.df$loadings1
flam_metrics_df_hp_scaled$PC2_test <- pc1.est.df$loadings2
flam_metrics_df_hp_scaled <- flam_metrics_df_hp_scaled %>% 
  mutate(PC1_test = scale(PC1_test, center = F)) %>% 
  mutate(PC2_test = scale(PC2_test, center = F))

flam_metrics_df_hp_scaled$PC1 <- PCAvalues.hp$PC1
flam_metrics_df_hp_scaled$PC2 <- PCAvalues.hp$PC2

ggplot(flam_metrics_df_hp_scaled, aes(x = PC1, y = PC1_test)) +
  labs(x = 'PC1', y = 'PC1 (loadings estimate)') +
  geom_point() +
  geom_abline() +
  theme_bw() +
  theme(axis.title = element_text(face = 'bold', size = 18),
        axis.text = element_text(size = 12))

ggplot(flam_metrics_df_hp_scaled, aes(x = PC2, y = PC2_test)) +
  labs(x = 'PC2', y = 'PC2 (loadings estimate)') +
  geom_point() +
  geom_abline() +
  theme_bw() +
  theme(axis.title = element_text(face = 'bold', size = 18),
        axis.text = element_text(size = 12))
```

### Step 2: EPI data > HP loadings (and vice versa)
```{r}
# Scaling and centering epi data
flam_metrics_df_epi_scaled <- flam_metrics_df_epi %>%
  mutate(temp_max = (temp_max - mean(temp_max))/sd(temp_max), fh = (fh - mean(fh))/sd(fh), fd = (fd - mean(fd))/sd(fd), gti = (gti - mean(gti))/sd(gti), tti = (tti - mean(tti))/sd(tti), ttfg = (ttfg - mean(ttfg))/sd(ttfg), pfg = (pfg - mean(pfg))/sd(pfg), gd = (gd - mean(gd))/sd(gd)) %>%
  mutate(temp_max = temp_max - mean(temp_max), fh = fh - mean(fh), fd = fd - mean(fd), gti = gti - mean(gti), gd = gd - mean(gd), tti = tti - mean(tti), ttfg = ttfg - mean(ttfg), pfg = pfg - mean(pfg))

# Taking out categorical variables, putting data into a matrix format
epi.flam.matrix <- flam_metrics_df_epi_scaled %>% 
  select(-spp, -model) %>% 
  data.matrix()

loadings1 <- c(-0.8141884, 0.4040835, 0.5617811, -1.2490785, -0.8381545, 0.3472839, -1.2219867, -0.8181686)
loadings2 <- c(-0.04216584, -0.54172313, 0.85477658, 0.25941237, 1.08141147, -0.97275148, -0.62375045, -0.62382705)

eigenvectors <- data.frame(loadings1, loadings2)
eigenvectors.matrix <- data.matrix(eigenvectors)

pc1.estimates <- epi.flam.matrix%*%eigenvectors.matrix
pc1.est.df <- data.frame(pc1.estimates)

flam_metrics_df_epi_scaled$PC1_hp.loadings <- pc1.est.df$loadings1
flam_metrics_df_epi_scaled$PC2_hp.loadings <- pc1.est.df$loadings2

flam_metrics_df_epi_scaled <- flam_metrics_df_epi_scaled %>% 
  mutate(PC1_hp.loadings = scale(PC1_hp.loadings, center = F)) %>% 
  mutate(PC2_hp.loadings = scale(PC2_hp.loadings, center = F))
```

Repeating above process, but with HP data > EPI loadings
```{r}
# Scaling and centering hp data
flam_metrics_df_hp_scaled <- flam_metrics_df_hp %>%
  mutate(temp_max = (temp_max - mean(temp_max))/sd(temp_max), fh = (fh - mean(fh))/sd(fh), fd = (fd - mean(fd))/sd(fd), gti = (gti - mean(gti))/sd(gti), tti = (tti - mean(tti))/sd(tti), ttfg = (ttfg - mean(ttfg))/sd(ttfg), pfg = (pfg - mean(pfg))/sd(pfg), gd = (gd - mean(gd))/sd(gd)) %>%
  mutate(temp_max = temp_max - mean(temp_max), fh = fh - mean(fh), fd = fd - mean(fd), gti = gti - mean(gti), gd = gd - mean(gd), tti = tti - mean(tti), ttfg = ttfg - mean(ttfg), pfg = pfg - mean(pfg))

# Taking out categorical variables, putting data into a matrix format
epi.flam.matrix <- flam_metrics_df_hp_scaled %>% 
  select(-spp, -model) %>% 
  data.matrix()

loadings1 <- c(0.59355984, 0.57408082, -0.20046595, -1.20313550, -1.19773609, 0.06690503, -1.21588167, -1.03258697)
loadings2 <- c(-0.95872777, -0.76806247, 0.02504162, 0.35895145, 0.35819506, -1.16431412, -0.82497010, -0.92073121)

eigenvectors <- data.frame(loadings1, loadings2)
eigenvectors.matrix <- data.matrix(eigenvectors)

pc1.estimates <- hp.flam.matrix%*%eigenvectors.matrix
pc1.est.df <- data.frame(pc1.estimates)

flam_metrics_df_hp_scaled$PC1_epi.loadings <- pc1.est.df$loadings1
flam_metrics_df_hp_scaled$PC2_epi.loadings <- pc1.est.df$loadings2

flam_metrics_df_hp_scaled <- flam_metrics_df_hp_scaled %>% 
  mutate(PC1_epi.loadings = scale(PC1_epi.loadings, center = F)) %>% 
  mutate(PC2_epi.loadings = scale(PC2_epi.loadings, center = F))
```

#### Combining Dataset
```{r}
flam_metrics_df_hp_scaled$PC1_hp.loadings <- PCAvalues.hp$PC1
flam_metrics_df_hp_scaled$PC2_hp.loadings <- PCAvalues.hp$PC2
flam_metrics_df_hp_scaled <- flam_metrics_df_hp_scaled %>% 
  select(-PC1)

flam_metrics_df_epi_scaled$PC1_epi.loadings <- PCAvalues.epi$PC1
flam_metrics_df_epi_scaled$PC2_epi.loadings <- PCAvalues.epi$PC2

PCAdf.IP <- rbind(flam_metrics_df_epi_scaled, flam_metrics_df_hp_scaled)
```


### Step 3: Visualization
#### HP Loadings
Setting up plot w/ HP loadings
```{r}
figure_pca_quant <- (flam_metrics_df_hp[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
         "temp_max")]) %>%  
 transmute("Flame Duration" = fd,
          "Flame Height" = fh,
          "Post-flame Glow" = pfg,
          "Time to Ignition" = tti,
          "Max. Temp" = temp_max,
          "Glow Duration" = gd,
          "Glow to Ignition" = gti,
          "Time to First Glow" = ttfg
          )

figure_pca_cat <- (flam_metrics_df_hp[c("spp")]) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus",
    spp == "CECO" ~ "C. cordulatus",
    spp == "ARPA" ~ "A. patula"
  ))

#Setting up plotting data: 

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj.hp <- figure_pca_quant %>% 
  prcomp(center = TRUE, scale = TRUE) #Running PCA

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj.hp$x) - 1)
    d <- pcobj.hp$sdev
    u <- sweep(pcobj.hp$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj.hp$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues.hp <- cbind(df.u, figure_pca_cat)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("Flame Height", "Max. Temp","Flame Duration"))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("Time to Ignition", "Glow to Ignition"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "Post-flame Glow", "Time to First Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)
```


```{r}
PCA.hploadings <- ggplot(data = PCAdf.IP, aes(x = PC1_hp.loadings, y = PC2_hp.loadings)) +
  labs(title = "Hot Plate Loadings", x = "PC1", y = "PC2") +
  geom_point(size = 1.75, alpha = .6, aes(shape = spp, color = model)) +
  stat_ellipse(aes(x = PC1_hp.loadings, y = PC2_hp.loadings, color = model), alpha = 0.8, cex = 0.8) +
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.key = element_rect(fill = "white"),
          legend.position = 'none',
          legend.title = element_text(face = 'bold', size = 18),
          legend.text = element_text(face = 'italic', size = 16),
          axis.title = element_text(face = 'bold', size = 18),
          plot.title = element_text(face = 'bold', size = 22),
          aspect.ratio = 1/1) +
  coord_equal() +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
      size = .9, alpha = 0.9) +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                            xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  annotate("text", 
          x = (PCA_combustability$PC1 * 1.85), 
          y = (PCA_combustability$PC2 * 1.12),
          label = PCA_combustability$Variables, size = 5,
          fontface = 'bold') +
  annotate("text",
           x = (PCA_ignitability$PC1 * 1.5), 
           y = (PCA_ignitability$PC2 * 1.125), 
           label = PCA_ignitability$Variables, size = 5, fontface = 'bold') +
  annotate("text",
           x = (PCA_consumability$PC1 * 1.5),
           y = (PCA_consumability$PC2 * 1.1), 
           label = PCA_consumability$Variables, size = 5,
           fontface = 'bold') + 
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.title = element_text(face = 'bold', size = 18),
          legend.text = element_text(face = 'italic', size = 16),
          axis.title = element_text(face = 'bold', size = 18),
          plot.title = element_text(face = 'bold', size = 22),
          aspect.ratio = 1/1) +
  scale_color_manual(values = c('gray70', 'black'))
PCA.hploadings
```

#### EPI Loadings
```{r}
figure_pca_quant <- (flam_metrics_df_epi[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
         "temp_max")]) %>%  
 transmute("Flame Duration" = fd,
          "Flame Height" = fh,
          "Post-flame Glow" = pfg,
          "Time to Ignition" = tti,
          "Max. Temp" = temp_max,
          "Glow Duration" = gd,
          "Glow to Ignition" = gti,
          "Time to First Glow" = ttfg
          )

figure_pca_cat <- (flam_metrics_df_epi[c("spp")]) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus",
    spp == "CECO" ~ "C. cordulatus",
    spp == "ARPA" ~ "A. patula"
  ))

#Setting up plotting data: 

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj.epi <- figure_pca_quant %>% 
  prcomp(center = TRUE, scale = TRUE) #Running PCA

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj.epi$x) - 1)
    d <- pcobj.epi$sdev
    u <- sweep(pcobj.epi$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj.epi$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues.epi <- cbind(df.u, figure_pca_cat)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("Flame Height", "Max. Temp","Flame Duration"))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("Time to Ignition", "Glow to Ignition"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "Post-flame Glow", "Time to First Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)
```


```{r}
PCA.epiloadings <- ggplot(data = PCAdf.IP, aes(x = PC1_epi.loadings, y = PC2_epi.loadings)) +
  labs(title = "Epiradiator Loadings", x = "PC1", y = "PC2") +
  geom_point(size = 1.75, alpha = .6, aes(shape = spp, color = model)) +
  stat_ellipse(aes(x = PC1_epi.loadings, y = PC2_epi.loadings, color = model), alpha = 0.8, cex = 0.8) +
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.key = element_rect(fill = "white"),
          legend.position = 'none',
          legend.title = element_text(face = 'bold', size = 18),
          legend.text = element_text(face = 'italic', size = 16),
          axis.title = element_text(face = 'bold', size = 18),
          plot.title = element_text(face = 'bold', size = 22),
          aspect.ratio = 1/1) +
  coord_equal() +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
      size = .9, alpha = 0.9) +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                            xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .9, alpha = 0.9) +
  annotate("text", 
          x = (PCA_combustability$PC1 * 1.85), 
          y = (PCA_combustability$PC2 * 1.12),
          label = PCA_combustability$Variables, size = 5,
          fontface = 'bold') +
  annotate("text",
           x = (PCA_ignitability$PC1 * 1.5), 
           y = (PCA_ignitability$PC2 * 1.125), 
           label = PCA_ignitability$Variables, size = 5, fontface = 'bold') +
  annotate("text",
           x = (PCA_consumability$PC1 * 1.5),
           y = (PCA_consumability$PC2 * 1.1), 
           label = PCA_consumability$Variables, size = 5,
           fontface = 'bold') + 
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank(),
          legend.title = element_text(face = 'bold', size = 18),
          legend.text = element_text(face = 'italic', size = 16),
          axis.title = element_text(face = 'bold', size = 18),
          plot.title = element_text(face = 'bold', size = 22),
          aspect.ratio = 1/1) +
  scale_color_manual(values = c('gray70', 'black'))
PCA.epiloadings
```

#### Arranging Plots
```{r}
pca2_legend <- get_legend(
  # create some space to the left of the legend
  ggplot() + 
  geom_point(data= PCAdf.IP, aes(PC1_hp.loadings, PC2_hp.loadings, color = model, shape = spp), size = 5, alpha = .8) +
    stat_ellipse(data = PCAdf.IP, aes(PC1_hp.loadings, PC2_hp.loadings, color = model)) +
    labs(color = "Model", shape = "Species") +
    scale_color_manual(values = c('gray70', 'black')) + 
    theme(legend.box.margin = margin(0, 0, 0, 0),
          legend.position = "right",
          legend.text = element_text(size = 18),
          legend.title = element_text(face = 'bold', size = 22),
          legend.key = element_rect(fill = "white")))

ggarrange(PCA.hploadings, PCA.epiloadings, pca2_legend, ncol = 3, widths = c(3,3,1))
```


```{r}
ggplot(PCAdf.IP, aes(x = PC1_epi.loadings, y = PC1_hp.loadings, color = model)) +
  geom_point() +
  geom_smooth(method = 'lm', se = F)
```

# --------------------------------

# NMDS 

This code has some issues, but we ended up using the NMDS mostly for confirming our conclusions from the PCAs. Initially, we set out to do an NMDS to see if we could get a visualization that looked a bit better than the PCAs, but we ended up liking the PCA visualizations better -- the visualization of the relationships between flam. metrics of the PCA surpasses that of the NMDS. Note that the NMDS shows a clear difference between methods when not scaled/centered, but this difference disappears when scaled/centered by method. We attributed this to inherent differences in the scale and distribution of flam. metrics due to differences in sample size (i.e., larger samples have higher flame height, longer flame duration almost always). 

## Epiradiator
Before Visualization:
```{r}
# First, extracting flam. metric columns
epi_nmds_df <- flam_metrics_df_epi %>% 
  select(-spp, -model)

# Converting spp and model into factors for visualization
epi_nmds_df_full <- flam_metrics_df_epi %>% 
  mutate(spp = as.factor(spp)) %>% 
  mutate(model = as.factor(model))

# Converting it into a matrix
epi_nmds_matrix <- as.matrix(epi_nmds_df)

# Setting a seed
set.seed(16)

# Running NMDS
epiNMDS <- metaMDS(epi_nmds_matrix, distance = "bray")
```

Data Visualization:
```{r}
ordiplot(epiNMDS)

colvec<-c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3")

# Highlight all of the below lines to run
epiNMDSplot <- plot(epiNMDS)
with(epi_nmds_df_full,
     points(epiNMDS, cex = 1.2, col = colvec[spp], pch = 16))
ordiellipse(epiNMDS, groups = epi_nmds_df_full$spp, draw = "polygon", 
            label = TRUE, lty = 1, col = colvec)
orditorp(epiNMDS, display = "species", col="black", cex = 1)
legend("bottomright", c("Adenostomata fasciculatum", "Arctostaphylos patula", "Ceanothus cordulatus", "Ceanothus megacarpus"), title = "Species", 
       col= colvec, pch=15, cex=1)
epiNMDSplot
```

## Hot Plate
Before Visualization:
```{r}
# First, extracting flam. metric columns
hp_nmds_df <- flam_metrics_df_hp %>% 
  select(-spp, -model)

# Converting spp and model into factors for visualization
hp_nmds_df_full <- flam_metrics_df_hp %>% 
  mutate(spp = as.factor(spp)) %>% 
  mutate(model = as.factor(model))

# Converting it into a matrix
hp_nmds_matrix <- as.matrix(hp_nmds_df)

# Setting a seed
set.seed(16)

# Running NMDS
hpNMDS <- metaMDS(hp_nmds_matrix, distance = "bray")
```

Data Visualization:
```{r}
ordiplot(hpNMDS)
colvec2<-c("#E41A1C", "#377EB8", "#984EA3")

# Highlight all of the below lines to run
hpNMDSplot <- plot(hpNMDS)
with(hp_nmds_df_full,
     points(hpNMDS, cex = 1.2, col = colvec2[spp], pch = 16))
ordiellipse(hpNMDS, groups = hp_nmds_df_full$spp, draw = "polygon", 
            label = TRUE, lty = 1, col = colvec2)
orditorp(hpNMDS, display = "species", col="black", cex = 1)
legend("bottomright", c("Adenostomata fasciculatum", "Arctostaphylos patula", "Ceanothus megacarpus"), title = "Species", 
       col= colvec2, pch=15, cex=1)

hpNMDSplot
```


## All Species, Both Models

Before Visualization:

Scaling and Centering:

Below, I scaled and centered the flam. metrics according to each model. Without separating by model, it scales/centers by the results (i.e. by standard deviations, means) of both models together in one pool which does not make sense when comparing the two models separately.

```{r}
epi_df1 <- flam_metrics_df_epi %>% 
  na.omit() %>% 
  mutate(fh = fh - mean(fh), fd = fd - mean(fd), ttfg = ttfg - mean(ttfg), gti = gti -
          mean(gti), tti = tti - mean(tti), gd = gd - mean(gd), pfg = pfg - mean(pfg),
          temp_max = temp_max - mean(temp_max)) %>%  #centering
  mutate(fh = scale(fh), fd = scale(fd), ttfg = scale(ttfg), gti = scale(gti), tti =
           scale(tti), gd = scale(gd), pfg = scale(pfg), temp_max = scale(temp_max)) #scaled

hp_df1 <- flam_metrics_df_hp %>% 
  na.omit() %>% 
  mutate(fh = fh - mean(fh), fd = fd - mean(fd), ttfg = ttfg - mean(ttfg), gti = gti -
          mean(gti), tti = tti - mean(tti), gd = gd - mean(gd), pfg = pfg - mean(pfg),
          temp_max = temp_max - mean(temp_max)) %>%  #centering
  mutate(fh = scale(fh), fd = scale(fd), ttfg = scale(ttfg), gti = scale(gti), tti =
           scale(tti), gd = scale(gd), pfg = scale(pfg), temp_max = scale(temp_max)) #scaled
```

Stitching epi_df1 and hp_df1 together:
```{r}
both_df1 <- bind_rows(epi_df1, hp_df1)
```

Data prep., NMDS
```{r}
# First, extracting flam. metric columns
both_nmds_df <- both_df1 %>% 
  select(-spp, -model)

# Converting spp and model into factors for visualization
both_nmds_df_full <- both_df1 %>% 
  mutate(spp = as.factor(spp)) %>% 
  mutate(model = as.factor(model))

# Converting it into a matrix
both_nmds_matrix <- as.matrix(both_nmds_df)

# Setting a seed
set.seed(16)

# Running NMDS
bothNMDS <- metaMDS(both_nmds_matrix, distance = "bray")
```

Data Visualization
```{r}
ordiplot(bothNMDS)

pchvec <- c(15:18)
colvec2<-c("#E41A1C", "#377EB8")

# Highlight all of the below lines to run
bothNMDSplot <- plot(bothNMDS, yaxt = 'n', xaxt = 'n', ylab = '', xlab = '')
title(xlab = expression(bold("NMDS1")), ylab = expression(bold("NMDS2")), line = 0.5, cex.lab = 1.5)
with(both_nmds_df_full,
     points(bothNMDS, cex = 1.1, col = colvec2[model], pch = pchvec[spp]))
ordiellipse(bothNMDS, groups = both_nmds_df_full$model, draw = "polygon", 
            label = TRUE, lty = 1, col = colvec2, cex = 1.3)
#orditorp(bothNMDS, display = "species", col="black", cex = 1.1)
legend("bottomright", c("Epiradiator", "Hot Plate"), title = "Chamber Model", 
       col= colvec2, pch=15, cex=1.2)
legend("bottomleft", c("Adenostomata fasciculatum", "Arctostaphylos patula", "Ceanothus cordulatus", "Ceanothus megacarpus"), title = "Species", 
       pch= pchvec, col="black", cex=1.2)
bothNMDSplot
```


## Two Species, Both Models
Scaling and Centering:
```{r}
epi_df2 <- flam_metrics_df_epi %>% 
  filter(spp == "ARPA" | spp == "ADFA") %>% 
  na.omit() %>% 
  mutate(fh = fh - mean(fh), fd = fd - mean(fd), ttfg = ttfg - mean(ttfg), gti = gti -
          mean(gti), tti = tti - mean(tti), gd = gd - mean(gd), pfg = pfg - mean(pfg),
          temp_max = temp_max - mean(temp_max)) %>%  #centering
  mutate(fh = scale(fh), fd = scale(fd), ttfg = scale(ttfg), gti = scale(gti), tti =
           scale(tti), gd = scale(gd), pfg = scale(pfg), temp_max = scale(temp_max)) #scaled

hp_df2 <- flam_metrics_df_hp %>%  
  filter(spp == "ARPA" | spp == "ADFA") %>% 
  na.omit() %>% 
  mutate(fh = fh - mean(fh), fd = fd - mean(fd), ttfg = ttfg - mean(ttfg), gti = gti -
          mean(gti), tti = tti - mean(tti), gd = gd - mean(gd), pfg = pfg - mean(pfg),
          temp_max = temp_max - mean(temp_max)) %>%  #centering
  mutate(fh = scale(fh), fd = scale(fd), ttfg = scale(ttfg), gti = scale(gti), tti =
           scale(tti), gd = scale(gd), pfg = scale(pfg), temp_max = scale(temp_max)) #scaled
```

Stitching epi_df2 and hp_df2 together:
```{r}
limit_df1 <- bind_rows(epi_df2, hp_df2)
```

Before Visualization:
```{r}
# First, extracting flam. metric columns
both_nmds_df <- limit_df1 %>% 
  filter(spp == "ADFA" | spp == "ARPA") %>% 
  select(-spp, -model)

# Converting spp and model into factors for visualization
both_nmds_df_full <- limit_df1 %>% 
  filter(spp == "ADFA" | spp == "ARPA") %>% 
  mutate(spp = as.factor(spp)) %>% 
  mutate(model = as.factor(model))

# Converting it into a matrix
both_nmds_matrix <- as.matrix(both_nmds_df)

# Setting a seed
set.seed(16)

# Running NMDS
bothNMDS <- metaMDS(both_nmds_matrix, distance = "bray")
```

Data Visualization:
```{r}
ordiplot(bothNMDS)

pchvec <- c(15:16)
colvec2<-c("#E41A1C", "#377EB8")

# Highlight all of the below lines to run
bothNMDSplot <- plot(bothNMDS, yaxt = 'n', xaxt = 'n', ylab = '', xlab = '')
title(xlab = expression(bold("NMDS1")), ylab = expression(bold("NMDS2")), line = 0.5, cex.lab = 1.5)
with(both_nmds_df_full,
     points(bothNMDS, cex = 1.1, col = colvec2[model], pch = pchvec[spp]))
ordiellipse(bothNMDS, groups = both_nmds_df_full$model, draw = "polygon", 
            label = TRUE, lty = 1, col = colvec2, cex = 1.3)
legend("bottomright", c("Epiradiator", "Hot Plate"), title = "Chamber Model", 
       col= colvec2, pch=15, cex=1.2)
legend("bottomleft", c("Adenostomata fasciculatum", "Arctostaphylos patula"), title = "Species", 
       pch= pchvec, col="black", cex=1.2)
bothNMDSplot
```